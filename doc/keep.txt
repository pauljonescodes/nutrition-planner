// calculatedNutritionInfo: async function (
//   this: RxItemDocument,
//   calcType: CalculationTypeEnum
// ): Promise<NutritionInfo> {
//   const thisSubitems = this.subitems ?? [];
//   if (thisSubitems.length === 0) {
//     switch (calcType) {
//       case CalculationTypeEnum.perServing:
//         return this.nutritionInfo();
//       case CalculationTypeEnum.total:
//         return multiplyNutritionInfo(this.nutritionInfo(), this.count);
//     }
//   } else {
//     var accumulatedNutritionInfo: NutritionInfo = baseNutritionInfo();
//     for (const subitem of thisSubitems ?? []) {
//       const item = await this.collection.findOne(subitem.itemId).exec();
//       const itemNutritionInfo =
//         (await item?.calculatedNutritionInfo(
//           CalculationTypeEnum.perServing
//         )) ?? baseNutritionInfo();
//       accumulatedNutritionInfo = addNutritionInfo(
//         accumulatedNutritionInfo,
//         divideNutritionInfo(
//           multiplyNutritionInfo(itemNutritionInfo, subitem.count ?? 0),
//           calcType === CalculationTypeEnum.perServing ? this.count : 1
//         )
//       );
//     }
//     return accumulatedNutritionInfo;
//   }
// },
// calculatedPriceCents: async function (
//   this: RxItemDocument,
//   calcType: CalculationTypeEnum
// ): Promise<number> {
//   const thisSubitems = this.subitems ?? [];
//   if (thisSubitems.length === 0) {
//     switch (calcType) {
//       case CalculationTypeEnum.perServing:
//         return this.priceCents / this.count;
//       case CalculationTypeEnum.total:
//         return this.priceCents;
//     }
//   } else {
//     var accumulatedServingPriceCents = 0;
//     for (const subitem of thisSubitems ?? []) {
//       const item = await this.collection.findOne(subitem.itemId).exec();
//       const itemPrice =
//         (await item?.calculatedPriceCents(CalculationTypeEnum.perServing)) ??
//         0;
//       accumulatedServingPriceCents +=
//         (itemPrice * (subitem.count ?? 0)) /
//         (calcType === CalculationTypeEnum.perServing ? this.count : 1);
//     }
//     return accumulatedServingPriceCents;
//   }
// },
// async upsertedLogCopy(this: RxItemDocument): Promise<RxItemDocument> {
//   const thisToJson = this.toMutableJSON();
//   thisToJson.id = dataid();
//   thisToJson.type = ItemTypeEnum.copy;
//   if (this.subitems === undefined || this.subitems.length === 0) {
//     return await this.collection.upsert(thisToJson);
//   } else {
//     const upsertedLogCopySubitems: Array<YupSubitemType> = [];
//     for (const rawSubitem of this.subitems) {
//       const foundItem = await this.collection
//         .findOne(rawSubitem.itemId!)
//         .exec();
//       if (foundItem !== null) {
//         const upsertedLogCopy = await foundItem.upsertedLogCopy();
//         if (upsertedLogCopy !== null) {
//           upsertedLogCopySubitems.push({
//             count: rawSubitem.count ?? 0,
//             itemId: upsertedLogCopy.id,
//           });
//         }
//       }
//     }
//     thisToJson.subitems = upsertedLogCopySubitems;
//     return await this.collection.upsert(thisToJson);
//   }
// },
/*

  */

  // findSubitems: async function (
  //   this: RxDBItemDocument
  // ): Promise<Array<RxDBItemDocument>> {
  //   if (this.subitems === undefined || this.subitems.length === 0) {
  //     return [];
  //   } else {
  //     const ids = this.subitems.map((value) => value.itemId!) ?? [];
  //     const findByIdsMap = await this.collection.findByIds(ids);
  //     return Array.from(findByIdsMap.values());
  //   }
  // },